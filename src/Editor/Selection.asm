; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\programovani\WoW Editor\Test\src\Editor\Selection.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?value@?$integral_constant@I$0A@@tr1@std@@2IB	; std::tr1::integral_constant<unsigned int,0>::value
PUBLIC	?_Rank@?$_Arithmetic_traits@_N@std@@2HB		; std::_Arithmetic_traits<bool>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@D@std@@2HB		; std::_Arithmetic_traits<char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@C@std@@2HB		; std::_Arithmetic_traits<signed char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@E@std@@2HB		; std::_Arithmetic_traits<unsigned char>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@F@std@@2HB		; std::_Arithmetic_traits<short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@G@std@@2HB		; std::_Arithmetic_traits<unsigned short>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@H@std@@2HB		; std::_Arithmetic_traits<int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@I@std@@2HB		; std::_Arithmetic_traits<unsigned int>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@J@std@@2HB		; std::_Arithmetic_traits<long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@K@std@@2HB		; std::_Arithmetic_traits<unsigned long>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_J@std@@2HB		; std::_Arithmetic_traits<__int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@_K@std@@2HB		; std::_Arithmetic_traits<unsigned __int64>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@M@std@@2HB		; std::_Arithmetic_traits<float>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@N@std@@2HB		; std::_Arithmetic_traits<double>::_Rank
PUBLIC	?_Rank@?$_Arithmetic_traits@O@std@@2HB		; std::_Arithmetic_traits<long double>::_Rank
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@O@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@O@std@@2HB DD 09H		; std::_Arithmetic_traits<long double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@N@std@@2HB DD 08H		; std::_Arithmetic_traits<double>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@M@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@M@std@@2HB DD 07H		; std::_Arithmetic_traits<float>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_K@std@@2HB DD 06H		; std::_Arithmetic_traits<unsigned __int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_J@std@@2HB DD 06H		; std::_Arithmetic_traits<__int64>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@K@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@K@std@@2HB DD 05H		; std::_Arithmetic_traits<unsigned long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@J@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@J@std@@2HB DD 05H		; std::_Arithmetic_traits<long>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@I@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@I@std@@2HB DD 04H		; std::_Arithmetic_traits<unsigned int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@H@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@H@std@@2HB DD 04H		; std::_Arithmetic_traits<int>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@G@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@G@std@@2HB DD 03H		; std::_Arithmetic_traits<unsigned short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@F@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@F@std@@2HB DD 03H		; std::_Arithmetic_traits<short>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@E@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@E@std@@2HB DD 02H		; std::_Arithmetic_traits<unsigned char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@C@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@C@std@@2HB DD 02H		; std::_Arithmetic_traits<signed char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@D@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@D@std@@2HB DD 02H		; std::_Arithmetic_traits<char>::_Rank
CONST	ENDS
;	COMDAT ?_Rank@?$_Arithmetic_traits@_N@std@@2HB
CONST	SEGMENT
?_Rank@?$_Arithmetic_traits@_N@std@@2HB DD 01H		; std::_Arithmetic_traits<bool>::_Rank
CONST	ENDS
;	COMDAT ?value@?$integral_constant@I$0A@@tr1@std@@2IB
CONST	SEGMENT
?value@?$integral_constant@I$0A@@tr1@std@@2IB DD 00H	; std::tr1::integral_constant<unsigned int,0>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
; Line 345
	push	ebp
	mov	ebp, esp
	push	esi
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
; Line 346
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
; Line 354
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
; Line 355
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new
; Line 56
	push	ebp
	mov	ebp, esp
; Line 57
	mov	eax, DWORD PTR __Where$[ebp]
; Line 58
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT
; Line 62
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
; Function compile flags: /Ogtp
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
; Line 490
	push	ebp
	mov	ebp, esp
; Line 491
	mov	eax, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [eax+1]
	npad	7
$LL3@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL3@length
	sub	eax, edx
; Line 492
	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtp
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT
; Line 496
	push	ebp
	mov	ebp, esp
; Line 498
	pop	ebp
; Line 497
	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
EXTRN	__imp__memmove:PROC
; Function compile flags: /Ogtp
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT
; Line 516
	push	ebp
	mov	ebp, esp
; Line 518
	pop	ebp
; Line 517
	jmp	DWORD PTR __imp__memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT
; Line 526
	push	ebp
	mov	ebp, esp
; Line 527
	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	edx, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [edx], cl
; Line 528
	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	edi
	mov	edi, DWORD PTR ___n$[ebp]
	dec	edi
	js	SHORT $LN1@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	esi
	mov	esi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, esi
	call	ebx
	add	esi, DWORD PTR ___s$[ebp]
	dec	edi
	jns	SHORT $LL2@vector
	pop	esi
	pop	ebx
$LN1@vector:
	pop	edi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 1511
	mov	eax, DWORD PTR [ecx+16]
; Line 1512
	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEAAPAVnameEntry@@I@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::operator[]
; Function compile flags: /Ogtp
;	COMDAT ??A?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEAAPAVnameEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEAAPAVnameEntry@@I@Z PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::operator[], COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 928
	push	ebp
	mov	ebp, esp
; Line 940
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [eax+ecx*4]
; Line 941
	pop	ebp
	ret	4
??A?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEAAPAVnameEntry@@I@Z ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 2008
	mov	eax, ecx
; Line 2010
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN4@Myptr
	mov	eax, DWORD PTR [eax]
$LN4@Myptr:
; Line 2011
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx
; Line 459
	ret	0
??1?$_String_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_String_val<char,std::allocator<char> >::~_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
; Line 161
	mov	eax, ecx
; Line 163
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx
; Line 165
	mov	eax, ecx
; Line 167
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBE_NPBQAVnameEntry@@@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBE_NPBQAVnameEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBE_NPBQAVnameEntry@@@Z PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Inside, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 1285
	push	ebp
	mov	ebp, esp
; Line 1286
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN3@Inside
	cmp	DWORD PTR [ecx], eax
	ja	SHORT $LN3@Inside
	mov	eax, 1
; Line 1287
	pop	ebp
	ret	4
$LN3@Inside:
; Line 1286
	xor	eax, eax
; Line 1287
	pop	ebp
	ret	4
?_Inside@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBE_NPBQAVnameEntry@@@Z ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEXPAPAVnameEntry@@0@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEXPAPAVnameEntry@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEXPAPAVnameEntry@@0@Z PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Orphan_range, COMDAT
; _this$ = ecx
; Line 1454
	ret	8
?_Orphan_range@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEXPAPAVnameEntry@@0@Z ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<nameEntry *,std::allocator<nameEntry *> >::~_Vector_val<nameEntry *,std::allocator<nameEntry *> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<nameEntry *,std::allocator<nameEntry *> >::~_Vector_val<nameEntry *,std::allocator<nameEntry *> >, COMDAT
; _this$ = ecx
; Line 434
	ret	0
??1?$_Vector_val@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<nameEntry *,std::allocator<nameEntry *> >::~_Vector_val<nameEntry *,std::allocator<nameEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVnameEntry@@@std@@QAE@XZ	; std::allocator<nameEntry *>::allocator<nameEntry *>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@PAVnameEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVnameEntry@@@std@@QAE@XZ PROC		; std::allocator<nameEntry *>::allocator<nameEntry *>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
; Line 161
	mov	eax, ecx
; Line 163
	ret	0
??0?$allocator@PAVnameEntry@@@std@@QAE@XZ ENDP		; std::allocator<nameEntry *>::allocator<nameEntry *>
_TEXT	ENDS
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtp
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 2002
	mov	eax, ecx
; Line 2004
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN4@Myptr@2
	mov	eax, DWORD PTR [eax]
$LN4@Myptr@2:
; Line 2005
	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
_TEXT	ENDS
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx
; Line 2020
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
; Line 181
	push	ebp
	mov	ebp, esp
; Line 182
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; Line 183
	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ ; std::vector<nameEntry *,std::allocator<nameEntry *> >::capacity
; Function compile flags: /Ogtp
;	COMDAT ?capacity@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::capacity, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 777
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; Line 778
	ret	0
?capacity@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ ; std::vector<nameEntry *,std::allocator<nameEntry *> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::size, COMDAT
; _this$ = ecx
; Line 879
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2
; Line 880
	ret	0
?size@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::size
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEXXZ ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Xlen
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEXXZ PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Xlen, COMDAT
; _this$ = ecx
; Line 1427
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEXXZ ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVnameEntry@@@std@@QAE@ABV01@@Z	; std::allocator<nameEntry *>::allocator<nameEntry *>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@PAVnameEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVnameEntry@@@std@@QAE@ABV01@@Z PROC	; std::allocator<nameEntry *>::allocator<nameEntry *>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
; Line 165
	mov	eax, ecx
; Line 167
	ret	4
??0?$allocator@PAVnameEntry@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<nameEntry *>::allocator<nameEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVnameEntry@@@std@@QAEXPAPAVnameEntry@@I@Z ; std::allocator<nameEntry *>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@PAVnameEntry@@@std@@QAEXPAPAVnameEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVnameEntry@@@std@@QAEXPAPAVnameEntry@@I@Z PROC ; std::allocator<nameEntry *>::deallocate, COMDAT
; _this$ = ecx
; Line 181
	push	ebp
	mov	ebp, esp
; Line 182
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; Line 183
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVnameEntry@@@std@@QAEXPAPAVnameEntry@@I@Z ENDP ; std::allocator<nameEntry *>::deallocate
_TEXT	ENDS
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 1972
	push	ebp
	mov	ebp, esp
	push	esi
; Line 1973
	mov	esi, DWORD PTR __Ptr$[ebp]
	test	esi, esi
	je	SHORT $LN2@Inside@2
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN8@Inside@2
	mov	eax, DWORD PTR [ecx]
	jmp	SHORT $LN9@Inside@2
$LN8@Inside@2:
	mov	eax, ecx
$LN9@Inside@2:
	cmp	esi, eax
	jb	SHORT $LN2@Inside@2
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN12@Inside@2
	mov	eax, DWORD PTR [ecx]
	jmp	SHORT $LN13@Inside@2
$LN12@Inside@2:
	mov	eax, ecx
$LN13@Inside@2:
	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, eax
	cmp	ecx, esi
	jbe	SHORT $LN2@Inside@2
; Line 1976
	mov	al, 1
	pop	esi
; Line 1977
	pop	ebp
	ret	4
$LN2@Inside@2:
; Line 1974
	xor	al, al
	pop	esi
; Line 1977
	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx
; Line 2015
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen@2:
$LN3@Xlen@2:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVnameEntry@@@std@@QBEIXZ ; std::allocator<nameEntry *>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@PAVnameEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVnameEntry@@@std@@QBEIXZ PROC	; std::allocator<nameEntry *>::max_size, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
; Line 219
	mov	eax, 1073741823				; 3fffffffH
; Line 220
	ret	0
?max_size@?$allocator@PAVnameEntry@@@std@@QBEIXZ ENDP	; std::allocator<nameEntry *>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx
; Line 219
	or	eax, -1
; Line 220
	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
PUBLIC	??$sprintf_s@$0PP@@@YAHAAY0PP@DPBDZZ		; sprintf_s<255>
EXTRN	__imp__vsprintf_s:PROC
; Function compile flags: /Ogtp
;	COMDAT ??$sprintf_s@$0PP@@@YAHAAY0PP@DPBDZZ
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Format$ = 12						; size = 4
??$sprintf_s@$0PP@@@YAHAAY0PP@DPBDZZ PROC		; sprintf_s<255>, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stdio.h
; Line 323
	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR __Format$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	ecx
	push	255					; 000000ffH
	push	edx
	call	DWORD PTR __imp__vsprintf_s
	add	esp, 16					; 00000010H
	pop	ebp
	ret	0
??$sprintf_s@$0PP@@@YAHAAY0PP@DPBDZZ ENDP		; sprintf_s<255>
_TEXT	ENDS
PUBLIC	??$addressof@PAVnameEntry@@@std@@YAPAPAVnameEntry@@AAPAV1@@Z ; std::addressof<nameEntry *>
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@PAVnameEntry@@@std@@YAPAPAVnameEntry@@AAPAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAVnameEntry@@@std@@YAPAPAVnameEntry@@AAPAV1@@Z PROC ; std::addressof<nameEntry *>, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
; Line 110
	push	ebp
	mov	ebp, esp
; Line 111
	mov	eax, DWORD PTR __Val$[ebp]
; Line 112
	pop	ebp
	ret	0
??$addressof@PAVnameEntry@@@std@@YAPAPAVnameEntry@@AAPAV1@@Z ENDP ; std::addressof<nameEntry *>
_TEXT	ENDS
PUBLIC	??$forward@PAVnameEntry@@@std@@YA$$QAPAVnameEntry@@AAPAV1@@Z ; std::forward<nameEntry *>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@PAVnameEntry@@@std@@YA$$QAPAVnameEntry@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVnameEntry@@@std@@YA$$QAPAVnameEntry@@AAPAV1@@Z PROC ; std::forward<nameEntry *>, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
; Line 78
	push	ebp
	mov	ebp, esp
; Line 79
	mov	eax, DWORD PTR __Arg$[ebp]
; Line 80
	pop	ebp
	ret	0
??$forward@PAVnameEntry@@@std@@YA$$QAPAVnameEntry@@AAPAV1@@Z ENDP ; std::forward<nameEntry *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVnameEntry@@@std@@YAPAPAVnameEntry@@IPAPAV1@@Z ; std::_Allocate<nameEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVnameEntry@@@std@@YAPAPAVnameEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T128869 = -12						; size = 12
$T128874 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVnameEntry@@@std@@YAPAPAVnameEntry@@IPAPAV1@@Z PROC ; std::_Allocate<nameEntry *>, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
; Line 30
	push	ebp
	mov	ebp, esp
; Line 33
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
; Line 35
	je	SHORT $LN5@Allocate
; Line 36
	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN1@Allocate
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
; Line 39
	jne	SHORT $LN5@Allocate
$LN1@Allocate:
; Line 37
	lea	ecx, DWORD PTR $T128874[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T128869[ebp]
	mov	DWORD PTR $T128874[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T128869[ebp]
	push	edx
	mov	DWORD PTR $T128869[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:
; Line 40
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@Allocate:
??$_Allocate@PAVnameEntry@@@std@@YAPAPAVnameEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<nameEntry *>
_TEXT	ENDS
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
$T128879 = -12						; size = 12
$T128883 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC			; std::_Allocate<char>, COMDAT
; Line 30
	push	ebp
	mov	ebp, esp
; Line 33
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
; Line 35
	je	SHORT $LN5@Allocate@2
; Line 36
	cmp	ecx, -1
	ja	SHORT $LN1@Allocate@2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
; Line 39
	jne	SHORT $LN5@Allocate@2
$LN1@Allocate@2:
; Line 37
	lea	eax, DWORD PTR $T128883[ebp]
	push	eax
	lea	ecx, DWORD PTR $T128879[ebp]
	mov	DWORD PTR $T128883[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T128879[ebp]
	push	ecx
	mov	DWORD PTR $T128879[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:
; Line 40
	mov	esp, ebp
	pop	ebp
	ret	0
$LN9@Allocate@2:
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAVnameEntry@@@std@@QAEXPAPAVnameEntry@@$$QAPAV3@@Z ; std::allocator<nameEntry *>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@PAVnameEntry@@@std@@QAEXPAPAVnameEntry@@$$QAPAV3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVnameEntry@@@std@@QAEXPAPAVnameEntry@@$$QAPAV3@@Z PROC ; std::allocator<nameEntry *>::construct, COMDAT
; _this$ = ecx
; Line 201
	push	ebp
	mov	ebp, esp
; Line 202
	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN3@construct:
; Line 203
	pop	ebp
	ret	8
?construct@?$allocator@PAVnameEntry@@@std@@QAEXPAPAVnameEntry@@$$QAPAV3@@Z ENDP ; std::allocator<nameEntry *>::construct
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVnameEntry@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVnameEntry@@0@Z ; std::_Ptr_cat<nameEntry *,nameEntry *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Ptr_cat@PAVnameEntry@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVnameEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVnameEntry@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVnameEntry@@0@Z PROC ; std::_Ptr_cat<nameEntry *,nameEntry *>, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
; Line 528
	push	ebp
	mov	ebp, esp
	push	ecx
; Line 530
	mov	al, BYTE PTR __Cat$[ebp]
; Line 531
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAVnameEntry@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVnameEntry@@0@Z ENDP ; std::_Ptr_cat<nameEntry *,nameEntry *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVnameEntry@@@std@@@std@@YAXPAPAVnameEntry@@0AAV?$allocator@PAVnameEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<nameEntry *> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVnameEntry@@@std@@@std@@YAXPAPAVnameEntry@@0AAV?$allocator@PAVnameEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVnameEntry@@@std@@@std@@YAXPAPAVnameEntry@@0AAV?$allocator@PAVnameEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<nameEntry *> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
; Line 105
	ret	0
??$_Destroy_range@V?$allocator@PAVnameEntry@@@std@@@std@@YAXPAPAVnameEntry@@0AAV?$allocator@PAVnameEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<nameEntry *> >
_TEXT	ENDS
PUBLIC	??$_Val_type@PAPAVnameEntry@@@std@@YAPAPAVnameEntry@@PAPAV1@@Z ; std::_Val_type<nameEntry * *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Val_type@PAPAVnameEntry@@@std@@YAPAPAVnameEntry@@PAPAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAVnameEntry@@@std@@YAPAPAVnameEntry@@PAPAV1@@Z PROC ; std::_Val_type<nameEntry * *>, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
; Line 802
	xor	eax, eax
; Line 803
	ret	0
??$_Val_type@PAPAVnameEntry@@@std@@YAPAPAVnameEntry@@PAPAV1@@Z ENDP ; std::_Val_type<nameEntry * *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVnameEntry@@PAV1@PAV1@@std@@YAPAPAVnameEntry@@PAPAV1@00AAV?$allocator@PAVnameEntry@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<nameEntry *,nameEntry *,nameEntry *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninit_move@PAVnameEntry@@PAV1@PAV1@@std@@YAPAPAVnameEntry@@PAPAV1@00AAV?$allocator@PAVnameEntry@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAVnameEntry@@PAV1@PAV1@@std@@YAPAPAVnameEntry@@PAPAV1@00AAV?$allocator@PAVnameEntry@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<nameEntry *,nameEntry *,nameEntry *>, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
; Line 456
	push	ebp
	mov	ebp, esp
; Line 459
	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx
	push	esi
	sar	eax, 2
; Line 461
	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Dest$[ebp]
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi
; Line 462
	pop	ebp
	ret	0
??$_Uninit_move@PAVnameEntry@@PAV1@PAV1@@std@@YAPAPAVnameEntry@@PAPAV1@00AAV?$allocator@PAVnameEntry@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<nameEntry *,nameEntry *,nameEntry *>
_TEXT	ENDS
PUBLIC	?findEntry@nameEntryManager@@QAEPAVnameEntry@@I@Z ; nameEntryManager::findEntry
; Function compile flags: /Ogtp
;	COMDAT ?findEntry@nameEntryManager@@QAEPAVnameEntry@@I@Z
_TEXT	SEGMENT
_ref$ = 8						; size = 4
?findEntry@nameEntryManager@@QAEPAVnameEntry@@I@Z PROC	; nameEntryManager::findEntry, COMDAT
; _this$ = ecx
; File c:\programovani\wow editor\test\src\editor\selection.h
; Line 91
	push	ebp
	mov	ebp, esp
; Line 92
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _ref$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
; Line 93
	pop	ebp
	ret	4
?findEntry@nameEntryManager@@QAEPAVnameEntry@@I@Z ENDP	; nameEntryManager::findEntry
_TEXT	ENDS
PUBLIC	?getSelect@@YAPAVnameEntry@@I@Z			; getSelect
; Function compile flags: /Ogtp
_TEXT	SEGMENT
_pick$ = 8						; size = 4
?getSelect@@YAPAVnameEntry@@I@Z PROC			; getSelect
; File c:\programovani\wow editor\test\src\editor\selection.cpp
; Line 6
	push	ebp
	mov	ebp, esp
; Line 7
	mov	eax, DWORD PTR _pick$[ebp]
	mov	ecx, DWORD PTR ?SelectionNames@@3VnameEntryManager@@A+4
	mov	eax, DWORD PTR [ecx+eax*4]
; Line 8
	pop	ebp
	ret	0
?getSelect@@YAPAVnameEntry@@I@Z ENDP			; getSelect
_TEXT	ENDS
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
; Function compile flags: /Ogtp
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 1495
	mov	eax, ecx
; Line 1496
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN6@c_str
	mov	eax, DWORD PTR [eax]
$LN6@c_str:
; Line 1497
	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z PROC ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx
; Line 454
	mov	eax, ecx
; Line 455
	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@QAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@V?$allocator@PAVnameEntry@@@1@@Z ; std::_Vector_val<nameEntry *,std::allocator<nameEntry *> >::_Vector_val<nameEntry *,std::allocator<nameEntry *> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_val@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@V?$allocator@PAVnameEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@V?$allocator@PAVnameEntry@@@1@@Z PROC ; std::_Vector_val<nameEntry *,std::allocator<nameEntry *> >::_Vector_val<nameEntry *,std::allocator<nameEntry *> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 426
	mov	eax, ecx
; Line 427
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
; Line 428
	mov	DWORD PTR [eax+4], ecx
; Line 429
	mov	DWORD PTR [eax+8], ecx
; Line 430
	ret	4
??0?$_Vector_val@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@V?$allocator@PAVnameEntry@@@1@@Z ENDP ; std::_Vector_val<nameEntry *,std::allocator<nameEntry *> >::_Vector_val<nameEntry *,std::allocator<nameEntry *> >
_TEXT	ENDS
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtp
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 1952
	push	ebp
	mov	ebp, esp
; Line 1953
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jb	SHORT $LN5@Eos
	mov	ecx, DWORD PTR [ecx]
$LN5@Eos:
	mov	BYTE PTR [ecx+eax], 0
; Line 1954
	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ ; std::vector<nameEntry *,std::allocator<nameEntry *> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::max_size, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 884
	mov	eax, 1073741823				; 3fffffffH
; Line 885
	ret	0
?max_size@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEII@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEII@Z PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Grow_to, COMDAT
; _this$ = ecx
; Line 1274
	push	ebp
	mov	ebp, esp
; Line 1275
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
; Line 1278
	mov	edx, 1073741823				; 3fffffffH
	sar	eax, 2
	mov	ecx, eax
	shr	ecx, 1
	sub	edx, ecx
	cmp	edx, eax
	jae	SHORT $LN4@Grow_to
	xor	eax, eax
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	add	eax, ecx
$LN5@Grow_to:
; Line 1279
	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	eax, ecx
	jae	SHORT $LN1@Grow_to
; Line 1281
	mov	eax, ecx
$LN1@Grow_to:
; Line 1282
	pop	ebp
	ret	4
?_Grow_to@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IBEII@Z ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Grow_to
_TEXT	ENDS
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 1517
	mov	eax, -2					; fffffffeH
; Line 1518
	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVnameEntry@@@std@@QAEPAPAVnameEntry@@I@Z ; std::allocator<nameEntry *>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@PAVnameEntry@@@std@@QAEPAPAVnameEntry@@I@Z
_TEXT	SEGMENT
$T129025 = -12						; size = 12
$T129017 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVnameEntry@@@std@@QAEPAPAVnameEntry@@I@Z PROC ; std::allocator<nameEntry *>::allocate, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
; Line 186
	push	ebp
	mov	ebp, esp
; Line 187
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate
	cmp	ecx, 1073741823				; 3fffffffH
	ja	SHORT $LN3@allocate
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate
$LN3@allocate:
	lea	ecx, DWORD PTR $T129017[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T129025[ebp]
	mov	DWORD PTR $T129017[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T129025[ebp]
	push	edx
	mov	DWORD PTR $T129025[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate:
$LN1@allocate:
; Line 188
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@allocate:
?allocate@?$allocator@PAVnameEntry@@@std@@QAEPAPAVnameEntry@@I@Z ENDP ; std::allocator<nameEntry *>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
$T129042 = -12						; size = 12
$T129040 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx
; Line 186
	push	ebp
	mov	ebp, esp
; Line 187
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	esp, 12					; 0000000cH
	xor	eax, eax
	test	ecx, ecx
	je	SHORT $LN1@allocate@2
	cmp	ecx, -1
	ja	SHORT $LN3@allocate@2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN1@allocate@2
$LN3@allocate@2:
	lea	eax, DWORD PTR $T129040[ebp]
	push	eax
	lea	ecx, DWORD PTR $T129042[ebp]
	mov	DWORD PTR $T129040[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T129042[ebp]
	push	ecx
	mov	DWORD PTR $T129042[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:
; Line 188
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@allocate@2:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@PAVnameEntry@@@std@@PAVnameEntry@@PAV3@@std@@YAXAAV?$allocator@PAVnameEntry@@@0@PAPAVnameEntry@@$$QAPAV2@@Z ; std::_Cons_val<std::allocator<nameEntry *>,nameEntry *,nameEntry *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@PAVnameEntry@@@std@@PAVnameEntry@@PAV3@@std@@YAXAAV?$allocator@PAVnameEntry@@@0@PAPAVnameEntry@@$$QAPAV2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@PAVnameEntry@@@std@@PAVnameEntry@@PAV3@@std@@YAXAAV?$allocator@PAVnameEntry@@@0@PAPAVnameEntry@@$$QAPAV2@@Z PROC ; std::_Cons_val<std::allocator<nameEntry *>,nameEntry *,nameEntry *>, COMDAT
; Line 279
	push	ebp
	mov	ebp, esp
; Line 280
	mov	eax, DWORD PTR __Pdest$[ebp]
	test	eax, eax
	je	SHORT $LN7@Cons_val
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$LN7@Cons_val:
; Line 281
	pop	ebp
	ret	0
??$_Cons_val@V?$allocator@PAVnameEntry@@@std@@PAVnameEntry@@PAV3@@std@@YAXAAV?$allocator@PAVnameEntry@@@0@PAPAVnameEntry@@$$QAPAV2@@Z ENDP ; std::_Cons_val<std::allocator<nameEntry *>,nameEntry *,nameEntry *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVnameEntry@@@std@@@std@@YAXPAPAVnameEntry@@0AAV?$allocator@PAVnameEntry@@@0@@Z ; std::_Destroy_range<std::allocator<nameEntry *> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVnameEntry@@@std@@@std@@YAXPAPAVnameEntry@@0AAV?$allocator@PAVnameEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVnameEntry@@@std@@@std@@YAXPAPAVnameEntry@@0AAV?$allocator@PAVnameEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<nameEntry *> >, COMDAT
; Line 89
	ret	0
??$_Destroy_range@V?$allocator@PAVnameEntry@@@std@@@std@@YAXPAPAVnameEntry@@0AAV?$allocator@PAVnameEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<nameEntry *> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAPAVnameEntry@@PAPAV1@V?$allocator@PAVnameEntry@@@std@@@std@@YAPAPAVnameEntry@@PAPAV1@00AAV?$allocator@PAVnameEntry@@@0@@Z ; std::_Uninitialized_move<nameEntry * *,nameEntry * *,std::allocator<nameEntry *> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Uninitialized_move@PAPAVnameEntry@@PAPAV1@V?$allocator@PAVnameEntry@@@std@@@std@@YAPAPAVnameEntry@@PAPAV1@00AAV?$allocator@PAVnameEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVnameEntry@@PAPAV1@V?$allocator@PAVnameEntry@@@std@@@std@@YAPAPAVnameEntry@@PAPAV1@00AAV?$allocator@PAVnameEntry@@@0@@Z PROC ; std::_Uninitialized_move<nameEntry * *,nameEntry * *,std::allocator<nameEntry *> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
; Line 469
	push	ebp
	mov	ebp, esp
; Line 471
	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx
	push	esi
	sar	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Dest$[ebp]
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi
; Line 472
	pop	ebp
	ret	0
??$_Uninitialized_move@PAPAVnameEntry@@PAPAV1@V?$allocator@PAVnameEntry@@@std@@@std@@YAPAPAVnameEntry@@PAPAV1@00AAV?$allocator@PAVnameEntry@@@0@@Z ENDP ; std::_Uninitialized_move<nameEntry * *,nameEntry * *,std::allocator<nameEntry *> >
_TEXT	ENDS
PUBLIC	??0?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ ; std::vector<nameEntry *,std::allocator<nameEntry *> >::vector<nameEntry *,std::allocator<nameEntry *> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::vector<nameEntry *,std::allocator<nameEntry *> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 507
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
; Line 508
	ret	0
??0?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::vector<nameEntry *,std::allocator<nameEntry *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 1987
	push	ebp
	mov	ebp, esp
; Line 1988
	cmp	BYTE PTR __Built$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	je	SHORT $LN9@Tidy
; Line 1990
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN9@Tidy
; Line 1992
	push	ebx
	mov	ebx, DWORD PTR [esi]
; Line 1993
	test	edi, edi
	je	SHORT $LN7@Tidy
; Line 1994
	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN7@Tidy:
; Line 1995
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	ebx
$LN9@Tidy:
; Line 1998
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	BYTE PTR [edi+esi], 0
	pop	edi
	pop	esi
; Line 1999
	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx
; Line 1108
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; Line 1109
	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR __Off$[ebp]
	push	edi
	cmp	eax, ecx
	jae	SHORT $LN3@erase
; Line 1110
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN28@erase:
$LN3@erase:
; Line 1111
	mov	edi, DWORD PTR __Count$[ebp]
	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN2@erase
; Line 1112
	mov	edi, eax
$LN2@erase:
; Line 1113
	test	edi, edi
	je	SHORT $LN25@erase
; Line 1116
	mov	edx, DWORD PTR [esi+20]
	push	ebx
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN11@erase
	mov	ebx, DWORD PTR [esi]
	jmp	SHORT $LN12@erase
$LN11@erase:
	mov	ebx, esi
$LN12@erase:
	cmp	edx, 16					; 00000010H
	jb	SHORT $LN15@erase
	mov	edx, DWORD PTR [esi]
	jmp	SHORT $LN16@erase
$LN15@erase:
	mov	edx, esi
$LN16@erase:
	sub	eax, edi
	add	ebx, ecx
	push	eax
	add	ebx, edi
	add	edx, ecx
	push	ebx
	push	edx
	call	DWORD PTR __imp__memmove
; Line 1117
	mov	eax, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	sub	eax, edi
; Line 1118
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], eax
	pop	ebx
	jb	SHORT $LN23@erase
	mov	ecx, DWORD PTR [esi]
	mov	BYTE PTR [ecx+eax], 0
	pop	edi
; Line 1120
	mov	eax, esi
	pop	esi
; Line 1121
	pop	ebp
	ret	8
; Line 1118
$LN23@erase:
	mov	ecx, esi
	mov	BYTE PTR [ecx+eax], 0
$LN25@erase:
; Line 1120
	pop	edi
	mov	eax, esi
	pop	esi
; Line 1121
	pop	ebp
	ret	8
$LN27@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXPAPAVnameEntry@@0@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Destroy
; Function compile flags: /Ogtp
;	COMDAT ?_Destroy@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXPAPAVnameEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXPAPAVnameEntry@@0@Z PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Destroy, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 1271
	ret	8
?_Destroy@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXPAPAVnameEntry@@0@Z ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
$T129306 = -40						; size = 12
__Newres$ = -28						; size = 4
$T129283 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 1918
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
; Line 1919
	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	esi, eax
	or	esi, 15					; 0000000fH
; Line 1920
	cmp	esi, -2					; fffffffeH
	jbe	SHORT $LN9@Copy
; Line 1921
	mov	esi, eax
	jmp	SHORT $LN39@Copy
$LN9@Copy:
; Line 1922
	mov	ebx, DWORD PTR [edi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	esi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN39@Copy
; Line 1924
	mov	eax, -2					; fffffffeH
	sub	eax, ecx
; Line 1926
	lea	esi, DWORD PTR [ecx+ebx]
	cmp	ebx, eax
	jbe	SHORT $LN39@Copy
; Line 1928
	mov	esi, -2					; fffffffeH
$LN39@Copy:
; Line 1931
	xor	eax, eax
; Line 1932
	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	cmp	ecx, eax
	jbe	SHORT $LN47@Copy
	cmp	ecx, -1
	ja	SHORT $LN46@Copy
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN46@Copy
$LN47@Copy:
	mov	DWORD PTR __Ptr$[ebp], eax
	jmp	SHORT $LN19@Copy
$LN46@Copy:
	lea	ecx, DWORD PTR $T129283[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T129306[ebp]
	mov	DWORD PTR $T129283[ebp], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	edx, DWORD PTR $T129306[ebp]
	push	edx
	mov	DWORD PTR $T129306[ebp], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN112@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:
; Line 1934
	mov	eax, DWORD PTR __Newsize$[ebp]
; Line 1936
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	add	ecx, 24					; 00000018H
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
	mov	DWORD PTR __Ptr$[ebp], eax
; Line 1941
	mov	eax, $LN107@Copy
	ret	0
$LN107@Copy:
	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Newres$[ebp]
$LN19@Copy:
; Line 1943
	mov	ebx, DWORD PTR __Oldlen$[ebp]
	test	ebx, ebx
	je	SHORT $LN78@Copy
; Line 1944
	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN76@Copy
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN77@Copy
$LN76@Copy:
	mov	eax, edi
$LN77@Copy:
	push	ebx
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN78@Copy:
; Line 1945
	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN88@Copy
	mov	ecx, DWORD PTR [edi]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN88@Copy:
; Line 1946
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	BYTE PTR [edi], 0
	mov	DWORD PTR [edi], eax
; Line 1947
	mov	DWORD PTR [edi+20], esi
; Line 1948
	mov	DWORD PTR [edi+16], ebx
	cmp	esi, 16					; 00000010H
	jb	SHORT $LN102@Copy
	mov	edi, eax
$LN102@Copy:
	mov	BYTE PTR [edi+ebx], 0
; Line 1949
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:
; Line 1938
	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN64@Copy
	mov	edx, DWORD PTR [esi]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN64@Copy:
; Line 1939
	push	0
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	push	0
	mov	BYTE PTR [esi], 0
	call	__CxxThrowException@8
$LN113@Copy:
$LN111@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??$_Umove@PAPAVnameEntry@@@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEPAPAVnameEntry@@PAPAV2@00@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Umove<nameEntry * *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAPAVnameEntry@@@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEPAPAVnameEntry@@PAPAV2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVnameEntry@@@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEPAPAVnameEntry@@PAPAV2@00@Z PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Umove<nameEntry * *>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 1322
	push	ebp
	mov	ebp, esp
; Line 1325
	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, ecx
	push	esi
	sar	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	esi
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi
; Line 1326
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAVnameEntry@@@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEPAPAVnameEntry@@PAPAV2@00@Z ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Umove<nameEntry * *>
_TEXT	ENDS
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 550
	mov	eax, ecx
; Line 551
	mov	DWORD PTR [eax+20], 15			; 0000000fH
	mov	DWORD PTR [eax+16], 0
	mov	BYTE PTR [eax], 0
; Line 552
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx
; Line 752
	push	esi
	mov	esi, ecx
; Line 753
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN11@basic_stri
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@basic_stri:
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0
	pop	esi
; Line 754
	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXXZ ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Tidy, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 1301
	push	esi
	mov	esi, ecx
; Line 1302
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN6@Tidy@2
; Line 1307
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@Tidy@2:
; Line 1309
	mov	DWORD PTR [esi], 0
; Line 1310
	mov	DWORD PTR [esi+4], 0
; Line 1311
	mov	DWORD PTR [esi+8], 0
	pop	esi
; Line 1312
	ret	0
?_Tidy@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtp
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 1958
	push	ebp
	mov	ebp, esp
	push	ebx
; Line 1959
	mov	ebx, DWORD PTR __Newsize$[ebp]
	push	esi
	mov	esi, ecx
	cmp	ebx, -2					; fffffffeH
	jbe	SHORT $LN6@Grow
; Line 1960
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN49@Grow:
$LN6@Grow:
; Line 1961
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, ebx
	jae	SHORT $LN5@Grow
; Line 1962
	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	ebx
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Line 1968
	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx
; Line 1969
	pop	ebp
	ret	8
$LN5@Grow:
; Line 1963
	cmp	BYTE PTR __Trim$[ebp], 0
	je	SHORT $LN3@Grow
	cmp	ebx, 16					; 00000010H
	jae	SHORT $LN3@Grow
; Line 1965
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	ebx, edi
	jae	SHORT $LN9@Grow
	mov	edi, ebx
$LN9@Grow:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN30@Grow
	mov	ebx, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN28@Grow
	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN28@Grow:
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	mov	ebx, DWORD PTR __Newsize$[ebp]
	add	esp, 4
$LN30@Grow:
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], 15			; 0000000fH
; Line 1968
	xor	ecx, ecx
	mov	BYTE PTR [edi+esi], 0
	cmp	ecx, ebx
	pop	edi
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx
; Line 1969
	pop	ebp
	ret	8
$LN3@Grow:
; Line 1966
	test	ebx, ebx
	jne	SHORT $LN46@Grow
; Line 1967
	mov	DWORD PTR [esi+16], ebx
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN44@Grow
	mov	esi, DWORD PTR [esi]
$LN44@Grow:
	mov	BYTE PTR [esi], 0
$LN46@Grow:
; Line 1968
	xor	ecx, ecx
	cmp	ecx, ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebx
; Line 1969
	pop	ebp
	ret	8
$LN48@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
PUBLIC	?reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEXI@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::reserve
; Function compile flags: /Ogtp
;	COMDAT ?reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEXI@Z PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::reserve, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 746
	push	ebp
	mov	ebp, esp
; Line 747
	mov	eax, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, ecx
	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@reserve
; Line 748
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN43@reserve:
$LN5@reserve:
; Line 749
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	sar	ecx, 2
	cmp	ecx, eax
	jae	SHORT $LN3@reserve
; Line 751
	push	ebx
	push	edi
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	call	?allocate@?$allocator@PAVnameEntry@@@std@@QAEPAPAVnameEntry@@I@Z ; std::allocator<nameEntry *>::allocate
; Line 754
	mov	edx, DWORD PTR [esi+4]
	mov	ebx, eax
	mov	eax, DWORD PTR [esi]
	sub	edx, eax
	sar	edx, 2
	add	edx, edx
	add	edx, edx
	push	edx
	push	eax
	push	ebx
	call	DWORD PTR __imp__memmove
; Line 760
	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [esi+4]
	sub	edi, eax
	add	esp, 12					; 0000000cH
	sar	edi, 2
; Line 761
	test	eax, eax
	je	SHORT $LN37@reserve
; Line 765
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN37@reserve:
; Line 769
	mov	eax, DWORD PTR __Count$[ebp]
; Line 770
	lea	edx, DWORD PTR [ebx+edi*4]
	lea	ecx, DWORD PTR [ebx+eax*4]
	pop	edi
; Line 771
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+4], edx
	pop	ebx
$LN3@reserve:
	pop	esi
; Line 773
	pop	ebp
	ret	4
$LN42@reserve:
?reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEXI@Z ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::reserve
_TEXT	ENDS
PUBLIC	??1nameEntry@@QAE@XZ				; nameEntry::~nameEntry
; Function compile flags: /Ogtp
;	COMDAT ??1nameEntry@@QAE@XZ
_TEXT	SEGMENT
??1nameEntry@@QAE@XZ PROC				; nameEntry::~nameEntry, COMDAT
; _this$ = ecx
; File c:\programovani\wow editor\test\src\editor\selection.h
; Line 48
	push	esi
	mov	esi, ecx
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN14@nameEntry
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN14@nameEntry:
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0
	pop	esi
	ret	0
??1nameEntry@@QAE@XZ ENDP				; nameEntry::~nameEntry
_TEXT	ENDS
PUBLIC	??_GnameEntry@@QAEPAXI@Z			; nameEntry::`scalar deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_GnameEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GnameEntry@@QAEPAXI@Z PROC				; nameEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN16@scalar@2
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN16@scalar@2:
	test	BYTE PTR ___flags$[ebp], 1
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0
	je	SHORT $LN28@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN28@scalar@2:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GnameEntry@@QAEPAXI@Z ENDP				; nameEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ ; std::vector<nameEntry *,std::allocator<nameEntry *> >::~vector<nameEntry *,std::allocator<nameEntry *> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::~vector<nameEntry *,std::allocator<nameEntry *> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 704
	push	esi
	mov	esi, ecx
; Line 705
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN8@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@vector@2:
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	pop	esi
; Line 706
	ret	0
??1?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::~vector<nameEntry *,std::allocator<nameEntry *> >
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 892
	push	ebp
	mov	ebp, esp
	push	ebx
; Line 893
	mov	ebx, DWORD PTR __Roff$[ebp]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	push	edi
	mov	edi, DWORD PTR [ecx+16]
	cmp	edi, ebx
	jae	SHORT $LN5@assign
; Line 894
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN83@assign:
$LN5@assign:
; Line 896
	mov	eax, DWORD PTR __Count$[ebp]
	sub	edi, ebx
	cmp	eax, edi
	jae	SHORT $LN4@assign
; Line 897
	mov	edi, eax
$LN4@assign:
; Line 899
	cmp	esi, ecx
	jne	SHORT $LN3@assign
; Line 900
	push	-1
	add	edi, ebx
	push	edi
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	push	ebx
	push	0
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi
; Line 906
	mov	eax, esi
	pop	esi
	pop	ebx
; Line 907
	pop	ebp
	ret	12					; 0000000cH
$LN3@assign:
; Line 901
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN20@assign
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN84@assign:
$LN20@assign:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN19@assign
	mov	eax, DWORD PTR [esi+16]
	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Right$[ebp]
	test	edi, edi
	je	SHORT $LN78@assign
$LN82@assign:
; Line 903
	mov	eax, 16					; 00000010H
	cmp	DWORD PTR [ecx+20], eax
	jb	SHORT $LN64@assign
	mov	ecx, DWORD PTR [ecx]
$LN64@assign:
	cmp	DWORD PTR [esi+20], eax
	jb	SHORT $LN68@assign
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN69@assign
; Line 901
$LN19@assign:
	test	edi, edi
	jne	SHORT $LN82@assign
	mov	DWORD PTR [esi+16], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN58@assign
	mov	eax, DWORD PTR [esi]
	pop	edi
	mov	BYTE PTR [eax], 0
; Line 906
	mov	eax, esi
	pop	esi
	pop	ebx
; Line 907
	pop	ebp
	ret	12					; 0000000cH
; Line 901
$LN58@assign:
	pop	edi
	mov	eax, esi
	pop	esi
	mov	BYTE PTR [eax], 0
	pop	ebx
; Line 907
	pop	ebp
	ret	12					; 0000000cH
; Line 903
$LN68@assign:
	mov	eax, esi
$LN69@assign:
	push	edi
	add	ecx, ebx
	push	ecx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; Line 904
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], edi
	jb	SHORT $LN76@assign
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+edi], 0
	pop	edi
; Line 906
	mov	eax, esi
	pop	esi
	pop	ebx
; Line 907
	pop	ebp
	ret	12					; 0000000cH
; Line 904
$LN76@assign:
	mov	eax, esi
	mov	BYTE PTR [eax+edi], 0
$LN78@assign:
; Line 906
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
; Line 907
	pop	ebp
	ret	12					; 0000000cH
$LN80@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXI@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXI@Z PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Reserve, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 1290
	push	ebp
	mov	ebp, esp
; Line 1291
	mov	eax, DWORD PTR [ecx+4]
; Line 1292
	mov	edx, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	edi
	sub	eax, esi
	mov	edi, 1073741823				; 3fffffffH
	sar	eax, 2
	sub	edi, edx
	cmp	edi, eax
	jae	SHORT $LN4@Reserve
; Line 1293
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN34@Reserve:
$LN4@Reserve:
; Line 1294
	add	eax, edx
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, esi
	sar	edx, 2
	cmp	eax, edx
	jbe	SHORT $LN1@Reserve
; Line 1297
	mov	esi, edx
	shr	esi, 1
	mov	edi, 1073741823				; 3fffffffH
	sub	edi, esi
	cmp	edi, edx
	jae	SHORT $LN23@Reserve
	xor	edx, edx
	jmp	SHORT $LN24@Reserve
$LN23@Reserve:
	add	edx, esi
$LN24@Reserve:
	cmp	edx, eax
	jae	SHORT $LN20@Reserve
	mov	edx, eax
$LN20@Reserve:
	push	edx
	call	?reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEXI@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::reserve
$LN1@Reserve:
	pop	edi
	pop	esi
; Line 1298
	pop	ebp
	ret	4
$LN33@Reserve:
?_Reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXI@Z ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Reserve
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 910
	push	ebp
	mov	ebp, esp
	push	ebx
; Line 916
	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi
	mov	esi, ecx
	test	ebx, ebx
	je	SHORT $LN85@assign@2
	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN12@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN13@assign@2
$LN12@assign@2:
	mov	eax, esi
$LN13@assign@2:
	cmp	ebx, eax
	jb	SHORT $LN85@assign@2
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN16@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN17@assign@2
$LN16@assign@2:
	mov	eax, esi
$LN17@assign@2:
	mov	edx, DWORD PTR [esi+16]
	add	edx, eax
	cmp	edx, ebx
	jbe	SHORT $LN85@assign@2
; Line 917
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign@2
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	sub	ebx, eax
	push	ebx
	push	esi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx
; Line 925
	pop	ebp
	ret	8
; Line 917
$LN20@assign@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	eax, esi
	push	ecx
	sub	ebx, eax
	push	ebx
	push	esi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx
; Line 925
	pop	ebp
	ret	8
$LN85@assign@2:
	push	edi
; Line 919
	mov	edi, DWORD PTR __Count$[ebp]
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@assign@2
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN89@assign@2:
$LN27@assign@2:
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN26@assign@2
	mov	edx, DWORD PTR [esi+16]
	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
	je	SHORT $LN82@assign@2
$LN88@assign@2:
; Line 921
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN72@assign@2
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN73@assign@2
; Line 919
$LN26@assign@2:
	test	edi, edi
	jne	SHORT $LN88@assign@2
	mov	DWORD PTR [esi+16], edi
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN65@assign@2
	mov	eax, DWORD PTR [esi]
	pop	edi
	mov	BYTE PTR [eax], 0
; Line 924
	mov	eax, esi
	pop	esi
	pop	ebx
; Line 925
	pop	ebp
	ret	8
; Line 919
$LN65@assign@2:
	pop	edi
	mov	eax, esi
	pop	esi
	mov	BYTE PTR [eax], 0
	pop	ebx
; Line 925
	pop	ebp
	ret	8
; Line 921
$LN72@assign@2:
	mov	eax, esi
$LN73@assign@2:
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
; Line 922
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	mov	DWORD PTR [esi+16], edi
	jb	SHORT $LN80@assign@2
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [eax+edi], 0
	pop	edi
; Line 924
	mov	eax, esi
	pop	esi
	pop	ebx
; Line 925
	pop	ebp
	ret	8
; Line 922
$LN80@assign@2:
	mov	eax, esi
	mov	BYTE PTR [eax+edi], 0
$LN82@assign@2:
; Line 924
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
; Line 925
	pop	ebp
	ret	8
$LN86@assign@2:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	??1nameEntryManager@@QAE@XZ			; nameEntryManager::~nameEntryManager
; Function compile flags: /Ogtp
;	COMDAT ??1nameEntryManager@@QAE@XZ
_TEXT	SEGMENT
??1nameEntryManager@@QAE@XZ PROC			; nameEntryManager::~nameEntryManager, COMDAT
; _this$ = ecx
; File c:\programovani\wow editor\test\src\editor\selection.h
; Line 96
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN11@nameEntryM
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@nameEntryM:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi
	ret	0
??1nameEntryManager@@QAE@XZ ENDP			; nameEntryManager::~nameEntryManager
_TEXT	ENDS
PUBLIC	?del@nameEntryManager@@QAEXI@Z			; nameEntryManager::del
EXTRN	?CurSelection@@3PAVnameEntry@@A:DWORD		; CurSelection
EXTRN	?Selection@@3PAVnameEntry@@A:DWORD		; Selection
; Function compile flags: /Ogtp
_TEXT	SEGMENT
_Ref$ = 8						; size = 4
?del@nameEntryManager@@QAEXI@Z PROC			; nameEntryManager::del
; _this$ = ecx
; File c:\programovani\wow editor\test\src\editor\selection.cpp
; Line 34
	push	ebp
	mov	ebp, esp
	push	ebx
; Line 35
	mov	ebx, DWORD PTR _Ref$[ebp]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+ebx*4]
	xor	ecx, ecx
	cmp	eax, ecx
	je	SHORT $LN46@del
; Line 37
	cmp	DWORD PTR ?Selection@@3PAVnameEntry@@A, eax ; Selection
	jne	SHORT $LN2@del
; Line 38
	mov	DWORD PTR ?Selection@@3PAVnameEntry@@A, ecx ; Selection
$LN2@del:
; Line 39
	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR ?CurSelection@@3PAVnameEntry@@A ; CurSelection
	cmp	eax, DWORD PTR [edx+ebx*4]
	jne	SHORT $LN1@del
; Line 40
	mov	DWORD PTR ?CurSelection@@3PAVnameEntry@@A, ecx ; CurSelection
$LN1@del:
; Line 41
	mov	edx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR [edx+ebx*4]
	cmp	esi, ecx
	je	SHORT $LN45@del
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN31@del
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	ecx, ecx
$LN31@del:
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], ecx
	push	esi
	mov	BYTE PTR [esi], 0
	call	??3@YAXPAX@Z				; operator delete
; Line 43
	mov	ecx, DWORD PTR [edi+4]
	add	esp, 4
	pop	esi
	pop	edi
	mov	DWORD PTR [ecx+ebx*4], 0
	pop	ebx
; Line 44
	pop	ebp
	ret	4
$LN45@del:
	pop	esi
	pop	edi
; Line 43
	mov	DWORD PTR [edx+ebx*4], ecx
	pop	ebx
; Line 44
	pop	ebp
	ret	4
$LN46@del:
; Line 43
	mov	eax, DWORD PTR [edi+4]
	pop	edi
	mov	DWORD PTR [eax+ebx*4], ecx
	pop	ebx
; Line 44
	pop	ebp
	ret	4
?del@nameEntryManager@@QAEXI@Z ENDP			; nameEntryManager::del
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z PROC ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
; Line 631
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; Line 632
	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Val$[ebp]
	cmp	edi, eax
	jae	SHORT $LN4@push_back
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, edi
	ja	SHORT $LN4@push_back
; Line 634
	sub	edi, ecx
	sar	edi, 2
; Line 635
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN3@push_back
; Line 636
	push	1
	mov	ecx, esi
	call	?_Reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXI@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Reserve
$LN3@push_back:
; Line 640
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN41@push_back
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx+edi*4]
	mov	DWORD PTR [eax], edx
; Line 651
	add	DWORD PTR [esi+4], 4
	pop	edi
	pop	esi
; Line 653
	pop	ebp
	ret	4
$LN4@push_back:
; Line 645
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN1@push_back
; Line 646
	push	1
	mov	ecx, esi
	call	?_Reserve@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@IAEXI@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::_Reserve
$LN1@push_back:
; Line 650
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN41@push_back
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [eax], ecx
$LN41@push_back:
; Line 651
	add	DWORD PTR [esi+4], 4
	pop	edi
	pop	esi
; Line 653
	pop	ebp
	ret	4
?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z ENDP ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back
_TEXT	ENDS
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtp
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 928
	push	ebp
	mov	ebp, esp
	push	esi
; Line 930
	mov	esi, DWORD PTR __Ptr$[ebp]
	mov	eax, esi
	push	edi
	lea	edi, DWORD PTR [eax+1]
	npad	3
$LL5@assign@3:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL5@assign@3
	sub	eax, edi
	push	eax
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi
; Line 931
	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
PUBLIC	?deleteName@@YAXI@Z				; deleteName
; Function compile flags: /Ogtp
_TEXT	SEGMENT
_Name$ = 8						; size = 4
?deleteName@@YAXI@Z PROC				; deleteName
; File c:\programovani\wow editor\test\src\editor\selection.cpp
; Line 26
	push	ebp
	mov	ebp, esp
; Line 27
	mov	eax, DWORD PTR _Name$[ebp]
	push	eax
	mov	ecx, OFFSET ?SelectionNames@@3VnameEntryManager@@A ; SelectionNames
	call	?del@nameEntryManager@@QAEXI@Z		; nameEntryManager::del
; Line 28
	pop	ebp
	ret	0
?deleteName@@YAXI@Z ENDP				; deleteName
_TEXT	ENDS
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xstring
; Line 767
	push	ebp
	mov	ebp, esp
	push	esi
; Line 768
	mov	esi, DWORD PTR __Ptr$[ebp]
	mov	eax, esi
	push	edi
	lea	edi, DWORD PTR [eax+1]
	npad	3
$LL7@operator:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $LL7@operator
	sub	eax, edi
	push	eax
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi
; Line 769
	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
PUBLIC	??0nameEntry@@QAE@PAVModelInstance@@@Z		; nameEntry::nameEntry
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0nameEntry@@QAE@PAVModelInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0nameEntry@@QAE@PAVModelInstance@@@Z$0
__ehfuncinfo$??0nameEntry@@QAE@PAVModelInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0nameEntry@@QAE@PAVModelInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0nameEntry@@QAE@PAVModelInstance@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_mod$ = 8						; size = 4
??0nameEntry@@QAE@PAVModelInstance@@@Z PROC		; nameEntry::nameEntry, COMDAT
; _this$ = ecx
; File c:\programovani\wow editor\test\src\editor\selection.h
; Line 19
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0nameEntry@@QAE@PAVModelInstance@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0
; Line 22
	mov	eax, DWORD PTR _mod$[ebp]
	mov	DWORD PTR [esi+28], 1
	mov	DWORD PTR [esi+32], eax
; Line 23
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+28], 16			; 00000010H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	jb	SHORT $LN34@nameEntry@2
	mov	edx, DWORD PTR [eax+8]
	jmp	SHORT $LN35@nameEntry@2
$LN34@nameEntry@2:
	lea	edx, DWORD PTR [eax+8]
$LN35@nameEntry@2:
	mov	eax, edx
	lea	edi, DWORD PTR [eax+1]
$LL42@nameEntry@2:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL42@nameEntry@2
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Line 24
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0nameEntry@@QAE@PAVModelInstance@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0nameEntry@@QAE@PAVModelInstance@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0nameEntry@@QAE@PAVModelInstance@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0nameEntry@@QAE@PAVModelInstance@@@Z ENDP		; nameEntry::nameEntry
PUBLIC	??0nameEntry@@QAE@PAVWMOInstance@@@Z		; nameEntry::nameEntry
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??0nameEntry@@QAE@PAVWMOInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0nameEntry@@QAE@PAVWMOInstance@@@Z$0
__ehfuncinfo$??0nameEntry@@QAE@PAVWMOInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0nameEntry@@QAE@PAVWMOInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0nameEntry@@QAE@PAVWMOInstance@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_wmo$ = 8						; size = 4
??0nameEntry@@QAE@PAVWMOInstance@@@Z PROC		; nameEntry::nameEntry, COMDAT
; _this$ = ecx
; File c:\programovani\wow editor\test\src\editor\selection.h
; Line 26
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0nameEntry@@QAE@PAVWMOInstance@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	BYTE PTR [esi], 0
; Line 29
	mov	eax, DWORD PTR _wmo$[ebp]
	mov	DWORD PTR [esi+28], 2
	mov	DWORD PTR [esi+32], eax
; Line 30
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+28], 16			; 00000010H
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	jb	SHORT $LN34@nameEntry@3
	mov	edx, DWORD PTR [eax+8]
	jmp	SHORT $LN35@nameEntry@3
$LN34@nameEntry@3:
	lea	edx, DWORD PTR [eax+8]
$LN35@nameEntry@3:
	mov	eax, edx
	lea	edi, DWORD PTR [eax+1]
$LL42@nameEntry@3:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL42@nameEntry@3
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Line 31
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0nameEntry@@QAE@PAVWMOInstance@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0nameEntry@@QAE@PAVWMOInstance@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0nameEntry@@QAE@PAVWMOInstance@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0nameEntry@@QAE@PAVWMOInstance@@@Z ENDP		; nameEntry::nameEntry
PUBLIC	??_C@_0BD@MAEJAOCD@Map?5Chunk?5?$CI?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	??0nameEntry@@QAE@PAVMapChunk@@@Z		; nameEntry::nameEntry
;	COMDAT ??_C@_0BD@MAEJAOCD@Map?5Chunk?5?$CI?$CFd?0?5?$CFd?$CJ?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
CONST	SEGMENT
??_C@_0BD@MAEJAOCD@Map?5Chunk?5?$CI?$CFd?0?5?$CFd?$CJ?$AA@ DB 'Map Chunk '
	DB	'(%d, %d)', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0nameEntry@@QAE@PAVMapChunk@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0nameEntry@@QAE@PAVMapChunk@@@Z$0
__ehfuncinfo$??0nameEntry@@QAE@PAVMapChunk@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0nameEntry@@QAE@PAVMapChunk@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0nameEntry@@QAE@PAVMapChunk@@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -276					; size = 4
_Temp$ = -272						; size = 255
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_chunk$ = 8						; size = 4
??0nameEntry@@QAE@PAVMapChunk@@@Z PROC			; nameEntry::nameEntry, COMDAT
; _this$ = ecx
; File c:\programovani\wow editor\test\src\editor\selection.h
; Line 33
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0nameEntry@@QAE@PAVMapChunk@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _chunk$[ebp]
	mov	esi, ecx
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR _this$GSCopy$[ebp], esi
	mov	BYTE PTR [esi], 0
; Line 37
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+28], 3
; Line 38
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+4]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _Temp$[ebp]
	push	OFFSET ??_C@_0BD@MAEJAOCD@Map?5Chunk?5?$CI?$CFd?0?5?$CFd?$CJ?$AA@
	push	eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	??$sprintf_s@$0PP@@@YAHAAY0PP@DPBDZZ	; sprintf_s<255>
; Line 39
	lea	eax, DWORD PTR _Temp$[ebp]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR [eax+1]
	npad	2
$LL36@nameEntry@4:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL36@nameEntry@4
	sub	eax, edx
	push	eax
	lea	ecx, DWORD PTR _Temp$[ebp]
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Line 40
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0nameEntry@@QAE@PAVMapChunk@@@Z$0:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0nameEntry@@QAE@PAVMapChunk@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0nameEntry@@QAE@PAVMapChunk@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0nameEntry@@QAE@PAVMapChunk@@@Z ENDP			; nameEntry::nameEntry
PUBLIC	??_C@_04DBPMIOEO@Fake?$AA@			; `string'
PUBLIC	??0nameEntry@@QAE@XZ				; nameEntry::nameEntry
;	COMDAT ??_C@_04DBPMIOEO@Fake?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
CONST	SEGMENT
??_C@_04DBPMIOEO@Fake?$AA@ DB 'Fake', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0nameEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0nameEntry@@QAE@XZ$0
__ehfuncinfo$??0nameEntry@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0nameEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0nameEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0nameEntry@@QAE@XZ PROC				; nameEntry::nameEntry, COMDAT
; _this$ = ecx
; File c:\programovani\wow editor\test\src\editor\selection.h
; Line 42
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0nameEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	xor	eax, eax
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], eax
	mov	BYTE PTR [esi], al
; Line 45
	push	4
	push	OFFSET ??_C@_04DBPMIOEO@Fake?$AA@
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	mov	DWORD PTR [esi+28], eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Line 46
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0nameEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0nameEntry@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0nameEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0nameEntry@@QAE@XZ ENDP				; nameEntry::nameEntry
PUBLIC	?add@nameEntryManager@@QAEIPAVModelInstance@@@Z	; nameEntryManager::add
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?add@nameEntryManager@@QAEIPAVModelInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?add@nameEntryManager@@QAEIPAVModelInstance@@@Z$0
__ehfuncinfo$?add@nameEntryManager@@QAEIPAVModelInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?add@nameEntryManager@@QAEIPAVModelInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?add@nameEntryManager@@QAEIPAVModelInstance@@@Z
_TEXT	SEGMENT
$T131353 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T131351 = 8						; size = 4
_mod$ = 8						; size = 4
?add@nameEntryManager@@QAEIPAVModelInstance@@@Z PROC	; nameEntryManager::add, COMDAT
; _this$ = ecx
; Line 63
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?add@nameEntryManager@@QAEIPAVModelInstance@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; Line 64
	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T131353[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@add
	mov	ecx, DWORD PTR _mod$[ebp]
	push	ecx
	mov	ecx, eax
	call	??0nameEntry@@QAE@PAVModelInstance@@@Z	; nameEntry::nameEntry
	jmp	SHORT $LN4@add
$LN3@add:
	xor	eax, eax
$LN4@add:
	lea	edx, DWORD PTR $T131351[ebp]
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR $T131351[ebp], eax
	call	?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back
; Line 65
	inc	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi]
; Line 66
	dec	eax
; Line 67
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?add@nameEntryManager@@QAEIPAVModelInstance@@@Z$0:
	mov	eax, DWORD PTR $T131353[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?add@nameEntryManager@@QAEIPAVModelInstance@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?add@nameEntryManager@@QAEIPAVModelInstance@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?add@nameEntryManager@@QAEIPAVModelInstance@@@Z ENDP	; nameEntryManager::add
PUBLIC	?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z	; nameEntryManager::add
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z$0
__ehfuncinfo$?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z
_TEXT	SEGMENT
$T131367 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T131365 = 8						; size = 4
_wmo$ = 8						; size = 4
?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z PROC	; nameEntryManager::add, COMDAT
; _this$ = ecx
; Line 70
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; Line 71
	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T131367[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@add@2
	mov	ecx, DWORD PTR _wmo$[ebp]
	push	ecx
	mov	ecx, eax
	call	??0nameEntry@@QAE@PAVWMOInstance@@@Z	; nameEntry::nameEntry
	jmp	SHORT $LN4@add@2
$LN3@add@2:
	xor	eax, eax
$LN4@add@2:
	lea	edx, DWORD PTR $T131365[ebp]
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR $T131365[ebp], eax
	call	?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back
; Line 72
	inc	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi]
; Line 73
	dec	eax
; Line 74
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z$0:
	mov	eax, DWORD PTR $T131367[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?add@nameEntryManager@@QAEIPAVWMOInstance@@@Z ENDP	; nameEntryManager::add
PUBLIC	?add@nameEntryManager@@QAEIPAVMapChunk@@@Z	; nameEntryManager::add
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?add@nameEntryManager@@QAEIPAVMapChunk@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?add@nameEntryManager@@QAEIPAVMapChunk@@@Z$0
__ehfuncinfo$?add@nameEntryManager@@QAEIPAVMapChunk@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?add@nameEntryManager@@QAEIPAVMapChunk@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?add@nameEntryManager@@QAEIPAVMapChunk@@@Z
_TEXT	SEGMENT
$T131381 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T131379 = 8						; size = 4
_chunk$ = 8						; size = 4
?add@nameEntryManager@@QAEIPAVMapChunk@@@Z PROC		; nameEntryManager::add, COMDAT
; _this$ = ecx
; Line 77
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?add@nameEntryManager@@QAEIPAVMapChunk@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; Line 78
	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T131381[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@add@3
	mov	ecx, DWORD PTR _chunk$[ebp]
	push	ecx
	mov	ecx, eax
	call	??0nameEntry@@QAE@PAVMapChunk@@@Z	; nameEntry::nameEntry
	jmp	SHORT $LN4@add@3
$LN3@add@3:
	xor	eax, eax
$LN4@add@3:
	lea	edx, DWORD PTR $T131379[ebp]
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR $T131379[ebp], eax
	call	?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back
; Line 79
	inc	DWORD PTR [esi]
	mov	eax, DWORD PTR [esi]
; Line 80
	dec	eax
; Line 81
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?add@nameEntryManager@@QAEIPAVMapChunk@@@Z$0:
	mov	eax, DWORD PTR $T131381[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?add@nameEntryManager@@QAEIPAVMapChunk@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?add@nameEntryManager@@QAEIPAVMapChunk@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?add@nameEntryManager@@QAEIPAVMapChunk@@@Z ENDP		; nameEntryManager::add
PUBLIC	?addFake@nameEntryManager@@QAEXXZ		; nameEntryManager::addFake
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$?addFake@nameEntryManager@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addFake@nameEntryManager@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?addFake@nameEntryManager@@QAEXXZ$1
__ehfuncinfo$?addFake@nameEntryManager@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?addFake@nameEntryManager@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?addFake@nameEntryManager@@QAEXXZ
_TEXT	SEGMENT
$T131395 = -16						; size = 4
$T131393 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?addFake@nameEntryManager@@QAEXXZ PROC			; nameEntryManager::addFake, COMDAT
; _this$ = ecx
; File c:\programovani\wow editor\test\src\editor\selection.h
; Line 84
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addFake@nameEntryManager@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
; Line 85
	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T131395[ebp], esi
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	cmp	esi, eax
	je	SHORT $LN3@addFake
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], eax
	mov	BYTE PTR [esi], al
	push	4
	push	OFFSET ??_C@_04DBPMIOEO@Fake?$AA@
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR [esi+28], eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN4@addFake
$LN3@addFake:
	xor	esi, esi
$LN4@addFake:
	lea	eax, DWORD PTR $T131393[ebp]
	push	eax
	lea	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR $T131393[ebp], esi
	call	?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back
; Line 86
	inc	DWORD PTR [edi]
; Line 87
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addFake@nameEntryManager@@QAEXXZ$0:
	mov	eax, DWORD PTR $T131395[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?addFake@nameEntryManager@@QAEXXZ$1:
	mov	ecx, DWORD PTR $T131395[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?addFake@nameEntryManager@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addFake@nameEntryManager@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?addFake@nameEntryManager@@QAEXXZ ENDP			; nameEntryManager::addFake
PUBLIC	??0nameEntryManager@@QAE@XZ			; nameEntryManager::nameEntryManager
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??0nameEntryManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0nameEntryManager@@QAE@XZ$0
__ehfuncinfo$??0nameEntryManager@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0nameEntryManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0nameEntryManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0nameEntryManager@@QAE@XZ PROC			; nameEntryManager::nameEntryManager, COMDAT
; _this$ = ecx
; File c:\programovani\wow editor\test\src\editor\selection.h
; Line 95
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0nameEntryManager@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	xor	eax, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR __$EHRec$[ebp+8], eax
	mov	DWORD PTR [esi], eax
	call	?addFake@nameEntryManager@@QAEXXZ	; nameEntryManager::addFake
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0nameEntryManager@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ ; std::vector<nameEntry *,std::allocator<nameEntry *> >::~vector<nameEntry *,std::allocator<nameEntry *> >
__ehhandler$??0nameEntryManager@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0nameEntryManager@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0nameEntryManager@@QAE@XZ ENDP			; nameEntryManager::nameEntryManager
PUBLIC	?addNameModel@@YAIPAVModelInstance@@@Z		; addNameModel
xdata$x	SEGMENT
__unwindtable$?addNameModel@@YAIPAVModelInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addNameModel@@YAIPAVModelInstance@@@Z$0
__ehfuncinfo$?addNameModel@@YAIPAVModelInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?addNameModel@@YAIPAVModelInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
_TEXT	SEGMENT
$T131598 = -16						; size = 4
$T131596 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_model$ = 8						; size = 4
?addNameModel@@YAIPAVModelInstance@@@Z PROC		; addNameModel
; File c:\programovani\wow editor\test\src\editor\selection.cpp
; Line 11
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addNameModel@@YAIPAVModelInstance@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
; Line 12
	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T131598[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN5@addNameMod
	mov	ecx, DWORD PTR _model$[ebp]
	push	ecx
	mov	ecx, eax
	call	??0nameEntry@@QAE@PAVModelInstance@@@Z	; nameEntry::nameEntry
	jmp	SHORT $LN6@addNameMod
$LN5@addNameMod:
	xor	eax, eax
$LN6@addNameMod:
	lea	edx, DWORD PTR $T131596[ebp]
	push	edx
	mov	ecx, OFFSET ?SelectionNames@@3VnameEntryManager@@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR $T131596[ebp], eax
	call	?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back
	mov	eax, DWORD PTR ?SelectionNames@@3VnameEntryManager@@A
	inc	eax
	mov	DWORD PTR ?SelectionNames@@3VnameEntryManager@@A, eax
	dec	eax
; Line 13
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?addNameModel@@YAIPAVModelInstance@@@Z$0:
	mov	eax, DWORD PTR $T131598[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?addNameModel@@YAIPAVModelInstance@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addNameModel@@YAIPAVModelInstance@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addNameModel@@YAIPAVModelInstance@@@Z ENDP		; addNameModel
PUBLIC	?addNameWMO@@YAIPAVWMOInstance@@@Z		; addNameWMO
xdata$x	SEGMENT
__unwindtable$?addNameWMO@@YAIPAVWMOInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addNameWMO@@YAIPAVWMOInstance@@@Z$0
__ehfuncinfo$?addNameWMO@@YAIPAVWMOInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?addNameWMO@@YAIPAVWMOInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
_TEXT	SEGMENT
$T131617 = -16						; size = 4
$T131615 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_wmo$ = 8						; size = 4
?addNameWMO@@YAIPAVWMOInstance@@@Z PROC			; addNameWMO
; Line 16
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addNameWMO@@YAIPAVWMOInstance@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
; Line 17
	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T131617[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN5@addNameWMO
	mov	ecx, DWORD PTR _wmo$[ebp]
	push	ecx
	mov	ecx, eax
	call	??0nameEntry@@QAE@PAVWMOInstance@@@Z	; nameEntry::nameEntry
	jmp	SHORT $LN6@addNameWMO
$LN5@addNameWMO:
	xor	eax, eax
$LN6@addNameWMO:
	lea	edx, DWORD PTR $T131615[ebp]
	push	edx
	mov	ecx, OFFSET ?SelectionNames@@3VnameEntryManager@@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR $T131615[ebp], eax
	call	?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back
	mov	eax, DWORD PTR ?SelectionNames@@3VnameEntryManager@@A
	inc	eax
	mov	DWORD PTR ?SelectionNames@@3VnameEntryManager@@A, eax
	dec	eax
; Line 18
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?addNameWMO@@YAIPAVWMOInstance@@@Z$0:
	mov	eax, DWORD PTR $T131617[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?addNameWMO@@YAIPAVWMOInstance@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addNameWMO@@YAIPAVWMOInstance@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addNameWMO@@YAIPAVWMOInstance@@@Z ENDP			; addNameWMO
PUBLIC	?addNameMapChunk@@YAIPAVMapChunk@@@Z		; addNameMapChunk
xdata$x	SEGMENT
__unwindtable$?addNameMapChunk@@YAIPAVMapChunk@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addNameMapChunk@@YAIPAVMapChunk@@@Z$0
__ehfuncinfo$?addNameMapChunk@@YAIPAVMapChunk@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?addNameMapChunk@@YAIPAVMapChunk@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
_TEXT	SEGMENT
$T131636 = -16						; size = 4
$T131634 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_chunk$ = 8						; size = 4
?addNameMapChunk@@YAIPAVMapChunk@@@Z PROC		; addNameMapChunk
; Line 21
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addNameMapChunk@@YAIPAVMapChunk@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
; Line 22
	push	36					; 00000024H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T131636[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN5@addNameMap
	mov	ecx, DWORD PTR _chunk$[ebp]
	push	ecx
	mov	ecx, eax
	call	??0nameEntry@@QAE@PAVMapChunk@@@Z	; nameEntry::nameEntry
	jmp	SHORT $LN6@addNameMap
$LN5@addNameMap:
	xor	eax, eax
$LN6@addNameMap:
	lea	edx, DWORD PTR $T131634[ebp]
	push	edx
	mov	ecx, OFFSET ?SelectionNames@@3VnameEntryManager@@A+4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR $T131634[ebp], eax
	call	?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back
	mov	eax, DWORD PTR ?SelectionNames@@3VnameEntryManager@@A
	inc	eax
	mov	DWORD PTR ?SelectionNames@@3VnameEntryManager@@A, eax
	dec	eax
; Line 23
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?addNameMapChunk@@YAIPAVMapChunk@@@Z$0:
	mov	eax, DWORD PTR $T131636[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?addNameMapChunk@@YAIPAVMapChunk@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addNameMapChunk@@YAIPAVMapChunk@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addNameMapChunk@@YAIPAVMapChunk@@@Z ENDP		; addNameMapChunk
EXTRN	_atexit:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\iosfwd
xdata$x	SEGMENT
__unwindtable$??__ESelectionNames@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__ESelectionNames@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??__ESelectionNames@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??__ESelectionNames@@YAXXZ$2
__ehfuncinfo$??__ESelectionNames@@YAXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??__ESelectionNames@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??__ESelectionNames@@YAXXZ
text$yc	SEGMENT
$T131884 = -16						; size = 4
$T131882 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??__ESelectionNames@@YAXXZ PROC				; `dynamic initializer for 'SelectionNames'', COMDAT
; File c:\programovani\wow editor\test\src\editor\selection.cpp
; Line 3
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??__ESelectionNames@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	xor	ebx, ebx
	push	36					; 00000024H
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T131884[ebp], esi
	cmp	esi, ebx
	je	SHORT $LN16@dynamic
	mov	DWORD PTR [esi+20], 15			; 0000000fH
	mov	DWORD PTR [esi+16], ebx
	mov	BYTE PTR [esi], bl
	push	4
	push	OFFSET ??_C@_04DBPMIOEO@Fake?$AA@
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR [esi+28], ebx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	jmp	SHORT $LN17@dynamic
$LN16@dynamic:
	xor	esi, esi
$LN17@dynamic:
	lea	eax, DWORD PTR $T131882[ebp]
	push	eax
	mov	ecx, OFFSET ?SelectionNames@@3VnameEntryManager@@A+4
	mov	BYTE PTR __$EHRec$[ebp+8], bl
	mov	DWORD PTR $T131882[ebp], esi
	call	?push_back@?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAEX$$QAPAVnameEntry@@@Z ; std::vector<nameEntry *,std::allocator<nameEntry *> >::push_back
	inc	DWORD PTR ?SelectionNames@@3VnameEntryManager@@A
	push	OFFSET ??__FSelectionNames@@YAXXZ	; `dynamic atexit destructor for 'SelectionNames''
	call	_atexit
	add	esp, 4
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
text$yc	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__ESelectionNames@@YAXXZ$0:
	mov	ecx, OFFSET ?SelectionNames@@3VnameEntryManager@@A+4
	jmp	??1?$vector@PAVnameEntry@@V?$allocator@PAVnameEntry@@@std@@@std@@QAE@XZ ; std::vector<nameEntry *,std::allocator<nameEntry *> >::~vector<nameEntry *,std::allocator<nameEntry *> >
__unwindfunclet$??__ESelectionNames@@YAXXZ$1:
	mov	eax, DWORD PTR $T131884[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??__ESelectionNames@@YAXXZ$2:
	mov	ecx, DWORD PTR $T131884[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??__ESelectionNames@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??__ESelectionNames@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__ESelectionNames@@YAXXZ ENDP				; `dynamic initializer for 'SelectionNames''
; Function compile flags: /Ogtp
;	COMDAT ??__FSelectionNames@@YAXXZ
text$yd	SEGMENT
??__FSelectionNames@@YAXXZ PROC				; `dynamic atexit destructor for 'SelectionNames'', COMDAT
	mov	eax, DWORD PTR ?SelectionNames@@3VnameEntryManager@@A+4
	test	eax, eax
	je	SHORT $LN12@dynamic@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN12@dynamic@2:
	mov	DWORD PTR ?SelectionNames@@3VnameEntryManager@@A+4, 0
	mov	DWORD PTR ?SelectionNames@@3VnameEntryManager@@A+8, 0
	mov	DWORD PTR ?SelectionNames@@3VnameEntryManager@@A+12, 0
	ret	0
??__FSelectionNames@@YAXXZ ENDP				; `dynamic atexit destructor for 'SelectionNames''
text$yd	ENDS
PUBLIC	?SelectionNames@@3VnameEntryManager@@A		; SelectionNames
_BSS	SEGMENT
?SelectionNames@@3VnameEntryManager@@A DB 014H DUP (?)	; SelectionNames
_BSS	ENDS
CRT$XCU	SEGMENT
_SelectionNames$initializer$ DD FLAT:??__ESelectionNames@@YAXXZ
CRT$XCU	ENDS
END
